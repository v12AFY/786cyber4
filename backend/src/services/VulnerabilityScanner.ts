import { Server as SocketIOServer } from 'socket.io';

export interface VulnerabilityScanResult {
  id: string;
  cveId: string;
  title: string;
  description: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  cvssScore: number;
  affectedAssets: string[];
  category: string;
  publishedDate: string;
  discoveredDate: string;
  status: 'Open' | 'In Progress' | 'Resolved';
  exploitAvailable: boolean;
  solution: string;
}

export interface ScanConfiguration {
  targets: string[];
  scanType: 'internal' | 'external' | 'comprehensive';
  includeCredentialedScans: boolean;
  excludePatterns?: string[];
  maxDuration?: number; // in minutes
}

export interface ScanProgress {
  scanId: string;
  status: 'queued' | 'running' | 'completed' | 'failed';
  progress: number; // 0-100
  startTime: string;
  estimatedCompletion?: string;
  currentTarget?: string;
  vulnerabilitiesFound: number;
}

export class VulnerabilityScanner {
  private io?: SocketIOServer;
  private activeScanId: string | null = null;
  private scanHistory: ScanProgress[] = [];

  constructor(io?: SocketIOServer) {
    this.io = io;
  }

  /**
   * Start the vulnerability scanner service
   */
  start(): void {
    console.log('Vulnerability Scanner service started');
    
    if (this.io) {
      this.io.on('connection', (socket) => {
        socket.on('vulnerability:scan:start', async (config: ScanConfiguration) => {
          try {
            const result = await this.startScan(config);
            socket.emit('vulnerability:scan:started', result);
          } catch (error) {
            socket.emit('vulnerability:scan:error', { error: error instanceof Error ? error.message : 'Unknown error' });
          }
        });

        socket.on('vulnerability:scan:status', (scanId: string) => {
          const status = this.getScanStatus(scanId);
          socket.emit('vulnerability:scan:status', status);
        });

        socket.on('vulnerability:scan:cancel', (scanId: string) => {
          const cancelled = this.cancelScan(scanId);
          socket.emit('vulnerability:scan:cancelled', { scanId, cancelled });
        });
      });
    }
  }

  // Mock vulnerability database
  private mockVulnerabilities: VulnerabilityScanResult[] = [
    {
      id: '1',
      cveId: 'CVE-2024-0001',
      title: 'Windows RCE Vulnerability',
      description: 'Remote code execution in Windows Print Spooler service',
      severity: 'Critical',
      cvssScore: 9.8,
      affectedAssets: ['DC-Server-01', 'Finance-WS-05', 'HR-WS-12'],
      category: 'Operating System',
      publishedDate: '2024-01-10',
      discoveredDate: '2024-01-12',
      status: 'Open',
      exploitAvailable: true,
      solution: 'Apply Windows Security Update KB5034441'
    },
    {
      id: '2',
      cveId: 'CVE-2023-9876',
      title: 'Apache HTTP Server Buffer Overflow',
      description: 'Buffer overflow vulnerability in Apache HTTP Server',
      severity: 'High',
      cvssScore: 8.1,
      affectedAssets: ['Web-Server-01'],
      category: 'Web Application',
      publishedDate: '2023-12-15',
      discoveredDate: '2024-01-05',
      status: 'In Progress',
      exploitAvailable: false,
      solution: 'Upgrade to Apache HTTP Server 2.4.58'
    },
    {
      id: '3',
      cveId: 'CVE-2023-5432',
      title: 'MySQL Privilege Escalation',
      description: 'Local privilege escalation in MySQL Server',
      severity: 'Medium',
      cvssScore: 6.7,
      affectedAssets: ['DB-Server-01'],
      category: 'Database',
      publishedDate: '2023-11-20',
      discoveredDate: '2024-01-08',
      status: 'Resolved',
      exploitAvailable: false,
      solution: 'Update to MySQL 8.0.35'
    }
  ];

  /**
   * Start a new vulnerability scan
   */
  async startScan(config: ScanConfiguration): Promise<{ scanId: string; message: string }> {
    if (this.activeScanId) {
      throw new Error('A scan is already in progress');
    }

    const scanId = `scan_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    this.activeScanId = scanId;

    const scanProgress: ScanProgress = {
      scanId,
      status: 'queued',
      progress: 0,
      startTime: new Date().toISOString(),
      vulnerabilitiesFound: 0
    };

    this.scanHistory.push(scanProgress);

    // Simulate scan execution
    this.simulateScan(scanId, config);

    return {
      scanId,
      message: 'Vulnerability scan started successfully'
    };
  }

  /**
   * Get the status of a specific scan
   */
  getScanStatus(scanId: string): ScanProgress | null {
    return this.scanHistory.find(scan => scan.scanId === scanId) || null;
  }

  /**
   * Get all scan history
   */
  getScanHistory(): ScanProgress[] {
    return [...this.scanHistory].reverse(); // Most recent first
  }

  /**
   * Get vulnerability scan results
   */
  getScanResults(scanId?: string): VulnerabilityScanResult[] {
    // In a real implementation, this would filter by scanId
    return this.mockVulnerabilities;
  }

  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStats(): {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    resolved: number;
    open: number;
  } {
    const vulns = this.mockVulnerabilities;
    
    return {
      total: vulns.length,
      critical: vulns.filter(v => v.severity === 'Critical').length,
      high: vulns.filter(v => v.severity === 'High').length,
      medium: vulns.filter(v => v.severity === 'Medium').length,
      low: vulns.filter(v => v.severity === 'Low').length,
      resolved: vulns.filter(v => v.status === 'Resolved').length,
      open: vulns.filter(v => v.status === 'Open').length
    };
  }

  /**
   * Update vulnerability status
   */
  updateVulnerabilityStatus(vulnerabilityId: string, status: 'Open' | 'In Progress' | 'Resolved'): boolean {
    const vuln = this.mockVulnerabilities.find(v => v.id === vulnerabilityId);
    if (vuln) {
      vuln.status = status;
      return true;
    }
    return false;
  }

  /**
   * Get vulnerabilities by severity
   */
  getVulnerabilitiesBySeverity(severity: 'Critical' | 'High' | 'Medium' | 'Low'): VulnerabilityScanResult[] {
    return this.mockVulnerabilities.filter(v => v.severity === severity);
  }

  /**
   * Get vulnerabilities by asset
   */
  getVulnerabilitiesByAsset(assetName: string): VulnerabilityScanResult[] {
    return this.mockVulnerabilities.filter(v => 
      v.affectedAssets.some(asset => 
        asset.toLowerCase().includes(assetName.toLowerCase())
      )
    );
  }

  /**
   * Cancel an active scan
   */
  cancelScan(scanId: string): boolean {
    if (this.activeScanId === scanId) {
      const scan = this.scanHistory.find(s => s.scanId === scanId);
      if (scan) {
        scan.status = 'failed';
        scan.progress = 0;
      }
      this.activeScanId = null;
      return true;
    }
    return false;
  }

  /**
   * Simulate a vulnerability scan execution
   */
  private async simulateScan(scanId: string, config: ScanConfiguration): Promise<void> {
    const scan = this.scanHistory.find(s => s.scanId === scanId);
    if (!scan) return;

    try {
      // Start scan
      scan.status = 'running';
      scan.progress = 0;
      
      const totalTargets = config.targets.length;
      const scanDuration = config.maxDuration || 30; // Default 30 minutes
      const progressInterval = (scanDuration * 60 * 1000) / 100; // Update every 1% of total time

      // Simulate scanning progress
      for (let i = 0; i <= 100; i += 5) {
        await new Promise(resolve => setTimeout(resolve, progressInterval * 5));
        
        if (scan.status === 'failed') {
          this.activeScanId = null;
          return;
        }

        scan.progress = i;
        scan.currentTarget = config.targets[Math.floor((i / 100) * totalTargets)] || 'Finalizing...';
        
        // Simulate finding vulnerabilities
        if (i > 20 && Math.random() > 0.7) {
          scan.vulnerabilitiesFound += Math.floor(Math.random() * 3);
        }

        // Emit progress updates via socket if available
        if (this.io) {
          this.io.emit('vulnerability:scan:progress', {
            scanId,
            progress: scan.progress,
            currentTarget: scan.currentTarget,
            vulnerabilitiesFound: scan.vulnerabilitiesFound
          });
        }
      }

      // Complete scan
      scan.status = 'completed';
      scan.progress = 100;
      scan.currentTarget = undefined;
      scan.vulnerabilitiesFound = this.mockVulnerabilities.length;
      
      this.activeScanId = null;

      // Emit completion event
      if (this.io) {
        this.io.emit('vulnerability:scan:completed', {
          scanId,
          vulnerabilitiesFound: scan.vulnerabilitiesFound
        });
      }

    } catch (error) {
      scan.status = 'failed';
      scan.progress = 0;
      this.activeScanId = null;

      // Emit error event
      if (this.io) {
        this.io.emit('vulnerability:scan:failed', {
          scanId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }
  }

  /**
   * Generate scan report
   */
  generateScanReport(scanId: string): {
    scanInfo: ScanProgress;
    vulnerabilities: VulnerabilityScanResult[];
    statistics: ReturnType<VulnerabilityScanner['getVulnerabilityStats']>;
    recommendations: string[];
  } {
    const scanInfo = this.getScanStatus(scanId);
    if (!scanInfo) {
      throw new Error('Scan not found');
    }

    const vulnerabilities = this.getScanResults(scanId);
    const statistics = this.getVulnerabilityStats();
    
    const recommendations = [
      'Prioritize patching Critical and High severity vulnerabilities',
      'Implement network segmentation to limit attack surface',
      'Enable automatic security updates where possible',
      'Conduct regular vulnerability assessments',
      'Maintain an asset inventory for better coverage'
    ];

    return {
      scanInfo,
      vulnerabilities,
      statistics,
      recommendations
    };
  }
}